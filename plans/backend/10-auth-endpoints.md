# 10 - Authentication Endpoints

## Overview

Device-based JWT authentication. No user login required - each device gets a token for API access.

---

## Flow

```
1. First Launch
   └── App generates UUID → stores in SecureStore

2. Register Device
   └── POST /api/v1/auth/register-device { device_id: "uuid" }
       └── Server creates device record
       └── Returns JWT (30-day expiry)

3. Authenticated Requests
   └── All requests include: Authorization: Bearer <token>

4. Token Refresh
   └── POST /api/v1/auth/refresh (before expiry)
       └── Returns new JWT

5. Future: Claim Device
   └── POST /api/v1/auth/claim-device { email, password }
       └── Links device to user account
```

---

## Pydantic Schemas

### app/schemas/auth.py

```python
from pydantic import BaseModel, Field
from datetime import datetime
import uuid


class DeviceRegisterRequest(BaseModel):
    """Request to register a new device."""

    device_id: str = Field(
        ...,
        min_length=36,
        max_length=36,
        description="UUID generated by the client app",
        json_schema_extra={"example": "550e8400-e29b-41d4-a716-446655440000"},
    )


class TokenResponse(BaseModel):
    """JWT token response."""

    access_token: str = Field(..., description="JWT access token")
    token_type: str = Field(default="bearer")
    expires_at: datetime = Field(..., description="Token expiration timestamp")


class DeviceInfo(BaseModel):
    """Device information."""

    id: uuid.UUID
    device_id: str
    created_at: datetime
    last_seen: datetime

    class Config:
        from_attributes = True
```

---

## Auth Service

### app/services/auth_service.py

```python
from datetime import datetime, timedelta, timezone
from jose import JWTError, jwt
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
import uuid

from app.config import get_settings
from app.models import Device

settings = get_settings()


class AuthService:
    def __init__(self, db: AsyncSession):
        self.db = db

    async def register_device(self, device_id: str) -> tuple[Device, str]:
        """Register a new device or return existing one."""

        # Check if device already exists
        stmt = select(Device).where(Device.device_id == device_id)
        result = await self.db.execute(stmt)
        device = result.scalar_one_or_none()

        if device:
            # Update last_seen
            device.last_seen = datetime.now(timezone.utc)
        else:
            # Create new device
            device = Device(device_id=device_id)
            self.db.add(device)

        await self.db.commit()
        await self.db.refresh(device)

        # Generate token
        token = self._create_token(device)

        return device, token

    async def get_device_by_id(self, device_db_id: uuid.UUID) -> Device | None:
        """Get device by database ID."""
        stmt = select(Device).where(Device.id == device_db_id)
        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()

    async def refresh_token(self, device: Device) -> str:
        """Generate a new token for an existing device."""
        device.last_seen = datetime.now(timezone.utc)
        await self.db.commit()
        return self._create_token(device)

    def _create_token(self, device: Device) -> str:
        """Create a JWT token for the device."""
        expires = datetime.now(timezone.utc) + timedelta(days=settings.jwt_expire_days)

        payload = {
            "sub": str(device.id),  # Device's database UUID
            "device_id": device.device_id,  # Client-generated UUID
            "exp": expires,
            "iat": datetime.now(timezone.utc),
        }

        return jwt.encode(payload, settings.jwt_secret, algorithm=settings.jwt_algorithm)

    @staticmethod
    def decode_token(token: str) -> dict | None:
        """Decode and validate a JWT token."""
        try:
            payload = jwt.decode(
                token,
                settings.jwt_secret,
                algorithms=[settings.jwt_algorithm],
            )
            return payload
        except JWTError:
            return None
```

---

## Dependencies

### app/api/deps.py

```python
from typing import Annotated
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.ext.asyncio import AsyncSession
import uuid

from app.database import get_db
from app.models import Device
from app.services.auth_service import AuthService

security = HTTPBearer()


async def get_current_device(
    credentials: Annotated[HTTPAuthorizationCredentials, Depends(security)],
    db: Annotated[AsyncSession, Depends(get_db)],
) -> Device:
    """Validate token and return the authenticated device."""

    token = credentials.credentials
    payload = AuthService.decode_token(token)

    if not payload:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token",
            headers={"WWW-Authenticate": "Bearer"},
        )

    device_id = payload.get("sub")
    if not device_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        )

    auth_service = AuthService(db)
    device = await auth_service.get_device_by_id(uuid.UUID(device_id))

    if not device:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Device not found",
        )

    return device


# Type alias for cleaner endpoint signatures
CurrentDevice = Annotated[Device, Depends(get_current_device)]
```

---

## Endpoints

### app/api/v1/auth.py

```python
from datetime import datetime, timedelta, timezone
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession

from app.database import get_db
from app.schemas.auth import DeviceRegisterRequest, TokenResponse, DeviceInfo
from app.services.auth_service import AuthService
from app.api.deps import CurrentDevice
from app.config import get_settings

router = APIRouter()
settings = get_settings()


@router.post(
    "/register-device",
    response_model=TokenResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Register a device",
    description="Register a new device or retrieve token for existing device.",
)
async def register_device(
    request: DeviceRegisterRequest,
    db: AsyncSession = Depends(get_db),
):
    auth_service = AuthService(db)
    device, token = await auth_service.register_device(request.device_id)

    expires_at = datetime.now(timezone.utc) + timedelta(days=settings.jwt_expire_days)

    return TokenResponse(
        access_token=token,
        expires_at=expires_at,
    )


@router.post(
    "/refresh",
    response_model=TokenResponse,
    summary="Refresh token",
    description="Get a new token before the current one expires.",
)
async def refresh_token(
    device: CurrentDevice,
    db: AsyncSession = Depends(get_db),
):
    auth_service = AuthService(db)
    token = await auth_service.refresh_token(device)

    expires_at = datetime.now(timezone.utc) + timedelta(days=settings.jwt_expire_days)

    return TokenResponse(
        access_token=token,
        expires_at=expires_at,
    )


@router.get(
    "/me",
    response_model=DeviceInfo,
    summary="Get current device info",
    description="Get information about the authenticated device.",
)
async def get_me(device: CurrentDevice):
    return device
```

---

## Frontend Integration

### services/auth.ts

```typescript
import * as SecureStore from 'expo-secure-store'
import { v4 as uuidv4 } from 'uuid'

const DEVICE_ID_KEY = 'lookyswappy_device_id'
const TOKEN_KEY = 'lookyswappy_auth_token'
const TOKEN_EXPIRES_KEY = 'lookyswappy_token_expires'

const API_URL = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:8000'

export async function getOrCreateDeviceId(): Promise<string> {
  let deviceId = await SecureStore.getItemAsync(DEVICE_ID_KEY)

  if (!deviceId) {
    deviceId = uuidv4()
    await SecureStore.setItemAsync(DEVICE_ID_KEY, deviceId)
  }

  return deviceId
}

export async function getAuthToken(): Promise<string | null> {
  const token = await SecureStore.getItemAsync(TOKEN_KEY)
  const expiresStr = await SecureStore.getItemAsync(TOKEN_EXPIRES_KEY)

  if (!token || !expiresStr) return null

  // Check if token is about to expire (within 1 day)
  const expires = new Date(expiresStr)
  const oneDayFromNow = new Date(Date.now() + 24 * 60 * 60 * 1000)

  if (expires < oneDayFromNow) {
    // Token is expiring soon, refresh it
    return await refreshToken()
  }

  return token
}

export async function registerDevice(): Promise<string> {
  const deviceId = await getOrCreateDeviceId()

  const response = await fetch(`${API_URL}/api/v1/auth/register-device`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ device_id: deviceId }),
  })

  if (!response.ok) {
    throw new Error('Failed to register device')
  }

  const data = await response.json()

  await SecureStore.setItemAsync(TOKEN_KEY, data.access_token)
  await SecureStore.setItemAsync(TOKEN_EXPIRES_KEY, data.expires_at)

  return data.access_token
}

export async function refreshToken(): Promise<string> {
  const currentToken = await SecureStore.getItemAsync(TOKEN_KEY)

  const response = await fetch(`${API_URL}/api/v1/auth/refresh`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${currentToken}`,
    },
  })

  if (!response.ok) {
    // Token invalid, re-register
    return await registerDevice()
  }

  const data = await response.json()

  await SecureStore.setItemAsync(TOKEN_KEY, data.access_token)
  await SecureStore.setItemAsync(TOKEN_EXPIRES_KEY, data.expires_at)

  return data.access_token
}

export async function getAuthHeaders(): Promise<Record<string, string>> {
  let token = await getAuthToken()

  if (!token) {
    token = await registerDevice()
  }

  return {
    Authorization: `Bearer ${token}`,
    'Content-Type': 'application/json',
  }
}
```

---

## Tasks

- [ ] Create auth schemas (Pydantic)
- [ ] Implement AuthService with JWT creation
- [ ] Create deps.py with get_current_device dependency
- [ ] Implement auth endpoints
- [ ] Test registration flow
- [ ] Test token refresh
- [ ] Implement frontend auth service
- [ ] Test end-to-end auth flow
